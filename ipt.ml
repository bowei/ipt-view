module Foo = struct
    type rule = {
        bar : int;
    }
end

type table =
    | Nat
    | Raw
    | Filter
    | Mangle
    | Security

let tableToStr = function
    | Nat -> "nat"
    | Raw -> "raw"
    | Filter -> "filter"
    | Mangle -> "mangle"
    | Security -> "security"

type target =
    | Accept
    | Drop
    | Return
    | Null

let targetToStr = function
    | Accept -> "ACCEPT"
    | Drop -> "DROP"
    | Return -> "RETURN"
    | Null -> "-"

module Parser = struct
    exception ParseError of string

    type line =
        | Table of table
        | Chain of string * target
        | Rule

    let lineToStr = function
        | Table x -> "table " ^ (tableToStr x)
        | Chain (name, target) -> "chain " ^ name ^ " " ^ (targetToStr target)
        | Rule -> "rule"

    let strToTable = function
        | "*nat" -> Nat
        | "*raw" -> Raw
        | "*filter" -> Filter
        | "*mangle" -> Mangle
        | "*security" -> Security
        | x -> raise (ParseError ("invalid table " ^ x))

    let strToTarget = function
        | "ACCEPT" -> Accept
        | "DROP" -> Drop
        | "RETURN" -> Return
        | "-" -> Null
        | x -> raise (ParseError ("invalid target " ^ x))

    let parseChain line =
        let re = Regexp.regexp ":([a-zA-Z0-9_-]+)\\s([a-zA-Z0-9_-]+)\\s.*" in
        match Regexp.string_match re line 0 with
            | None -> raise (ParseError ("invalid chain " ^ line))
            | Some result ->
                let chainName = Regexp.matched_group result 1 in
                let target = Regexp.matched_group result 2 in
                match chainName, target with
                    | None, _ -> raise (ParseError ("invalid chain " ^ line))
                    | _, None -> raise (ParseError ("invalid chain " ^ line))
                    | Some n, Some t -> Chain (n, (strToTarget t))

    let parseRule line = Rule

    let parse text =
        let lines = Regexp.split (Regexp.regexp "\n") text in
        let lines = List.filter (fun l -> (String.length l) > 0) lines in
        let lines = List.filter (fun l -> l.[0] != '#') lines in
        let rec mapfn line =
            if line.[0] = '*' then Table (strToTable line)
            else if line.[0] = ':' then (parseChain line)
            else (parseRule line) in
        let lines = List.map mapfn lines in
        lines
end

(* testing *)
let r = {Foo.bar = 777};;

Printf.printf "abc %d\n" r.Foo.bar;;

let xxxabc (x: int) (y: int) =
    Printf.printf "one %d %d\n" x y;
    Printf.printf "two\n";;

let s = "# Generated by iptables-save v1.6.0 on Sat Dec 24 22:17:26 2016
*nat
:PREROUTING ACCEPT [1986:465174]
:INPUT ACCEPT [656:99384]
:OUTPUT ACCEPT [19134:3690779]
:POSTROUTING ACCEPT [19131:3690659]
:DOCKER - [0:0]
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
-A DOCKER -i docker0 -j RETURN
COMMIT
# Completed on Sat Dec 24 22:17:26 2016
# Generated by iptables-save v1.6.0 on Sat Dec 24 22:17:26 2016
*filter
:INPUT ACCEPT [6717430:2380091707]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [13470053:18821978560]
:DOCKER - [0:0]
:DOCKER-ISOLATION - [0:0]
-A FORWARD -j DOCKER-ISOLATION
-A FORWARD -o docker0 -j DOCKER
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
-A DOCKER-ISOLATION -j RETURN
COMMIT
# Completed on Sat Dec 24 22:17:26 2016";;

let rec p x =
    match x with
    | [] -> ()
    | hd::tl -> Printf.printf "%s\n" (Parser.lineToStr hd); p tl;;

p (Parser.parse s);;